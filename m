Return-Path: <linux-scsi-owner@vger.kernel.org>
X-Original-To: lists+linux-scsi@lfdr.de
Delivered-To: lists+linux-scsi@lfdr.de
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.lfdr.de (Postfix) with ESMTP id 8AEEC1A5F34
	for <lists+linux-scsi@lfdr.de>; Sun, 12 Apr 2020 17:33:18 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1727063AbgDLPdR (ORCPT <rfc822;lists+linux-scsi@lfdr.de>);
        Sun, 12 Apr 2020 11:33:17 -0400
Received: from mail2-relais-roc.national.inria.fr ([192.134.164.83]:22480 "EHLO
        mail2-relais-roc.national.inria.fr" rhost-flags-OK-OK-OK-OK)
        by vger.kernel.org with ESMTP id S1726843AbgDLPdQ (ORCPT
        <rfc822;linux-scsi@vger.kernel.org>);
        Sun, 12 Apr 2020 11:33:16 -0400
X-IronPort-AV: E=Sophos;i="5.72,374,1580770800"; 
   d="scan'208";a="444884873"
Received: from abo-173-121-68.mrs.modulonet.fr (HELO hadrien) ([85.68.121.173])
  by mail2-relais-roc.national.inria.fr with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384; 12 Apr 2020 17:33:14 +0200
Date:   Sun, 12 Apr 2020 17:33:13 +0200 (CEST)
From:   Julia Lawall <julia.lawall@inria.fr>
X-X-Sender: jll@hadrien
To:     James Smart <jsmart2021@gmail.com>
cc:     linux-scsi@vger.kernel.org, dwagner@suse.de, maier@linux.ibm.com,
        bvanassche@acm.org, herbszt@gmx.de, natechancellor@gmail.com,
        rdunlap@infradead.org, hare@suse.de,
        James Smart <jsmart2021@gmail.com>,
        Ram Vegesna <ram.vegesna@broadcom.com>, kbuild@lists.01.org
Subject: [PATCH] elx: efct: fix zalloc-simple.cocci warnings
Message-ID: <alpine.DEB.2.21.2004121731450.2419@hadrien>
User-Agent: Alpine 2.21 (DEB 202 2017-01-01)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Sender: linux-scsi-owner@vger.kernel.org
Precedence: bulk
List-ID: <linux-scsi.vger.kernel.org>
X-Mailing-List: linux-scsi@vger.kernel.org

From: kbuild test robot <lkp@intel.com>

Use kzalloc instead of kmalloc/memset.

Generated by: scripts/coccinelle/api/alloc/zalloc-simple.cocci

CC: James Smart <jsmart2021@gmail.com>
Signed-off-by: kbuild test robot <lkp@intel.com>
Signed-off-by: Julia Lawall <julia.lawall@inria.fr>
---

url:    https://github.com/0day-ci/linux/commits/James-Smart/efct-Broadcom-Emulex-FC-Target-driver/20200412-114125
base:   https://git.kernel.org/pub/scm/linux/kernel/git/mkp/scsi.git for-next
:::::: branch date: 4 hours ago
:::::: commit date: 4 hours ago

 efct_hw.c |   61 +++++++++++++++++--------------------------------------------
 1 file changed, 17 insertions(+), 44 deletions(-)

--- a/drivers/scsi/elx/efct/efct_hw.c
+++ b/drivers/scsi/elx/efct/efct_hw.c
@@ -529,15 +529,12 @@ efct_hw_setup_io(struct efct_hw *hw)
 		}

 		/* Create WQE buffs for IO */
-		hw->wqe_buffs = kmalloc((hw->config.n_io *
-					     hw->sli.wqe_size),
-					     GFP_ATOMIC);
+		hw->wqe_buffs = kzalloc((hw->config.n_io * hw->sli.wqe_size),
+					GFP_ATOMIC);
 		if (!hw->wqe_buffs) {
 			kfree(hw->io);
 			return EFCT_HW_RTN_NO_MEMORY;
 		}
-		memset(hw->wqe_buffs, 0, (hw->config.n_io *
-					hw->sli.wqe_size));

 	} else {
 		/* re-use existing IOs, including SGLs */
@@ -3119,11 +3116,9 @@ efct_hw_get_sfp(struct efct_hw *hw, u16
 	struct efc_dma *dma;

 	/* mbxdata holds the header of the command */
-	mbxdata = kmalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
+	mbxdata = kzalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
 	if (!mbxdata)
 		return EFCT_HW_RTN_NO_MEMORY;
-
-	memset(mbxdata, 0, SLI4_BMBX_SIZE);
 	/*
 	 * cb_arg holds the data that will be passed to the callback on
 	 * completion
@@ -3226,12 +3221,10 @@ efct_hw_get_temperature(struct efct_hw *
 	struct efct_hw_temp_cb_arg *cb_arg;
 	u8 *mbxdata;

-	mbxdata = kmalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
+	mbxdata = kzalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
 	if (!mbxdata)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(mbxdata, 0, SLI4_BMBX_SIZE);
-
 	cb_arg = kmalloc(sizeof(*cb_arg), GFP_KERNEL);
 	if (!cb_arg) {
 		kfree(mbxdata);
@@ -3382,12 +3375,10 @@ efct_hw_get_link_stats(struct efct_hw *h
 	struct efct_hw_link_stat_cb_arg *cb_arg;
 	u8 *mbxdata;

-	mbxdata = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	mbxdata = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!mbxdata)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(mbxdata, 0, SLI4_BMBX_SIZE);
-
 	cb_arg = kmalloc(sizeof(*cb_arg), GFP_ATOMIC);
 	if (!cb_arg) {
 		kfree(mbxdata);
@@ -3481,12 +3472,10 @@ efct_hw_get_host_stats(struct efct_hw *h
 	struct efct_hw_host_stat_cb_arg *cb_arg;
 	u8 *mbxdata;

-	mbxdata = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	mbxdata = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!mbxdata)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(mbxdata, 0, SLI4_BMBX_SIZE);
-
 	cb_arg = kmalloc(sizeof(*cb_arg), GFP_ATOMIC);
 	if (!cb_arg) {
 		kfree(mbxdata);
@@ -3879,11 +3868,10 @@ efct_hw_async_call(struct efct_hw *hw,
 	 * we need this to be persistent as the mbox cmd submission may be
 	 * queued and executed later execution.
 	 */
-	ctx = kmalloc(sizeof(*ctx), GFP_ATOMIC);
+	ctx = kzalloc(sizeof(*ctx), GFP_ATOMIC);
 	if (!ctx)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(ctx, 0, sizeof(*ctx));
 	ctx->callback = callback;
 	ctx->arg = arg;

@@ -3974,14 +3962,13 @@ efct_hw_port_free_unreg_vpi(struct efc_s

 	/* Allocate memory and send unreg_vpi */
 	if (!data) {
-		data = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+		data = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 		if (!data) {
 			efct_hw_port_free_resources(sport,
 						    EFC_HW_PORT_FREE_FAIL,
 						    data);
 			return;
 		}
-		memset(data, 0, SLI4_BMBX_SIZE);
 	}

 	rc = sli_cmd_unreg_vpi(&hw->sli, data, SLI4_BMBX_SIZE,
@@ -4178,12 +4165,11 @@ efct_hw_port_alloc(struct efc *efc, stru
 	}

 	if (domain) {
-		cmd = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+		cmd = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 		if (!cmd) {
 			rc = EFCT_HW_RTN_NO_MEMORY;
 			goto efct_hw_port_alloc_out;
 		}
-		memset(cmd, 0, SLI4_BMBX_SIZE);

 		/*
 		 * If the WWPN is NULL, fetch the default
@@ -4260,11 +4246,10 @@ efct_hw_port_attach(struct efc *efc, str
 		return EFCT_HW_RTN_ERROR;
 	}

-	buf = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	buf = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!buf)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(buf, 0, SLI4_BMBX_SIZE);
 	sport->fc_id = fc_id;

 	rc = sli_cmd_reg_vpi(&hw->sli, buf, SLI4_BMBX_SIZE, sport->fc_id,
@@ -4506,12 +4491,10 @@ efct_hw_domain_alloc(struct efc *efc, st
 		return EFCT_HW_RTN_ERROR;
 	}

-	cmd = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	cmd = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!cmd)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(cmd, 0, SLI4_BMBX_SIZE);
-
 	/* allocate memory for the service parameters */
 	domain->dma.size = 112;
 	domain->dma.virt = dma_alloc_coherent(&efct->pcidev->dev,
@@ -4592,11 +4575,10 @@ efct_hw_domain_attach(struct efc *efc,
 		return EFCT_HW_RTN_ERROR;
 	}

-	buf = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	buf = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!buf)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(buf, 0, SLI4_BMBX_SIZE);
 	domain->sport->fc_id = fc_id;

 	rc = sli_cmd_reg_vfi(&hw->sli, buf, SLI4_BMBX_SIZE, domain->indicator,
@@ -4824,11 +4806,9 @@ efct_hw_node_attach(struct efc *efc, str
 		return EFCT_HW_RTN_ERROR;
 	}

-	buf = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	buf = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!buf)
 		return EFCT_HW_RTN_NO_MEMORY;
-
-	memset(buf, 0, SLI4_BMBX_SIZE);
 	/*
 	 * If the attach count is non-zero, this RPI has already been reg'd.
 	 * Otherwise, register the RPI
@@ -5000,11 +4980,10 @@ efct_hw_node_detach(struct efc *efc, str
 		if (!rnode->attached)
 			return EFCT_HW_RTN_SUCCESS_SYNC;

-		buf = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+		buf = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 		if (!buf)
 			return EFCT_HW_RTN_NO_MEMORY;

-		memset(buf, 0, SLI4_BMBX_SIZE);
 		count = atomic_sub_return(1, &hw->rpi_ref[index].rpi_count);
 		count++;
 		if (count <= 1) {
@@ -5093,12 +5072,10 @@ efct_hw_node_free_all(struct efct_hw *hw
 		return EFCT_HW_RTN_ERROR;
 	}

-	buf = kmalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
+	buf = kzalloc(SLI4_BMBX_SIZE, GFP_ATOMIC);
 	if (!buf)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(buf, 0, SLI4_BMBX_SIZE);
-
 	if (!sli_cmd_unreg_rpi(&hw->sli, buf, SLI4_BMBX_SIZE, 0xffff,
 			      SLI_RSRC_FCFI, U32_MAX))
 		rc = efct_hw_command(hw, buf, EFCT_CMD_NOWAIT,
@@ -5159,12 +5136,10 @@ efct_hw_get_nvparms(struct efct_hw *hw,
 	enum efct_hw_rtn rc = EFCT_HW_RTN_SUCCESS;

 	/* mbxdata holds the header of the command */
-	mbxdata = kmalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
+	mbxdata = kzalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
 	if (!mbxdata)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(mbxdata, 0, SLI4_BMBX_SIZE);
-
 	/*
 	 * cb_arg holds the data that will be passed to the callback on
 	 * completion
@@ -5303,12 +5278,10 @@ efct_hw_firmware_write_sli4_intf_2(struc
 	struct efct_hw_fw_wr_cb_arg *cb_arg;
 	int noc = 0;

-	mbxdata = kmalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
+	mbxdata = kzalloc(SLI4_BMBX_SIZE, GFP_KERNEL);
 	if (!mbxdata)
 		return EFCT_HW_RTN_NO_MEMORY;

-	memset(mbxdata, 0, SLI4_BMBX_SIZE);
-
 	cb_arg = kmalloc(sizeof(*cb_arg), GFP_KERNEL);
 	if (!cb_arg) {
 		kfree(mbxdata);
